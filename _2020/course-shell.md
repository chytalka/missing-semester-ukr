---
layout: lecture
title: "Огляд курсу + the shell"
date: 2020-01-13
ready: true
video:
  aspect: 56.25
  id: Z56Jmr9Z34Q
---

# Мотивація

Як програмісти, ми знаємо, що комп'ютери чудово допомагають у 
виконанні циклічних завдань. Однак дуже часто ми забуваємо, що це 
можна застосувати як до нашої роботи з комп'ютером, так і до 
обчислень, які виконують програми. У нас під рукою є широкий спектр 
інструментів, які дозволяють нам бути більш продуктивними й 
вирішувати складніші завдання та проблеми, які пов'язані з 
комп'ютером. Проте багато хто з нас використовує лише невелику 
частину цих інструментів; ми знаємо лише невелику кількість "магічних 
заклинань", але коли потрапляємо у скрутне становище, сліпо копіюємо 
команди з інтернету.

Даний курс є спробою вирішити цю проблему.

Ми хочемо навчити вас, як ефективно використовувати знайомі вам 
інструменти, і прагнемо показати нові, які вам варто додати до свого 
арсеналу. Ми хочемо викликати інтерес у вас та прищепити бажання до 
подальшого вивчення (можливо, навіть створення) додаткових програм. Ми 
вважаємо, що саме цього семестру бракує більшості навчальних програм з 
інформатики.

# Структура курсу

Курс складається з 11 лекцій (тривалістю 1 година), кожна з яких 
присвячена [певній темі](/2020/). Кожна лекція є незалежною від інших 
лекцій, але впродовж семестру ми будемо вважати, що ви вже знайомі з 
матеріалом попередніх лекцій. У нас є конспекти лекцій, але на заняттях 
розглядається багато матеріалу, якого може не бути в конспектах. Усі 
записи лекцій також розміщені у відкритому доступі.

Ми намагаємося охопити велику кількість матеріалу протягом 11 годин 
лекцій, тому лекції досить щільні. Щоб у вас був час ознайомитися з 
матеріалом у власному темпі, кожна лекція включає набір вправ, які 
допоможуть вам засвоїти основні моменти. 

Через обмежений час ми не зможемо охопити всі аспекти з тим же рівнем 
деталізації, що й повноцінний курс. По можливості ми вкажемо вам на 
ресурси для подальшого самостійного вивчення.

# Лекція 1: The Shell

## Що таке shell?

Сьогодні комп'ютери мають різноманітні інтерфейси для команд; графічні, 
голосові інтерфейси й навіть AR/VR є скрізь. Вони чудово підходять для 
80% випадків використання, але часто вони обмежені певним набором 
команд - ви не зможете натиснути кнопку, якої немає, або дати голосову 
команду, яка не була запрограмована. Щоб повною мірою використовувати 
інструменти, які надає комп'ютер, ми повинні повернутися до старої школи 
й перейти до текстового інтерфейсу: The Shell (CLI - Command Line 
Interface, оболонка, консоль, командний рядок).

Майже всі платформи мають оболонку, а деякі з них мають навіть декілька 
оболонок на вибір. Хоча вони можуть відрізнятися в деталях, за своєю 
суттю всі вони приблизно однакові: вони дозволяють запускати програми, 
вводити вхідні дані та виводити їхній результат у напівструктурований 
спосіб.

У цій лекції ми зосередимося на оболонці Bourne Again SHell, або 
скорочено bash. Це одна з найпоширеніших оболонок, синтаксис якої схожий 
на синтаксис багатьох інших оболонок. Щоб відкрити _командний рядок_ (де 
ви зможете вводити команди), вам спочатку потрібен  _термінал_. Ваш 
пристрій, ймовірно, має встановлений термінал, в іншому випадку, ви 
можете досить таки легко встановити його.

## Використання оболонки

Після запуску термінала ви можете побачити:

```console
missing:~$ 
```

Це основний текстовий інтерфейс оболонки. Він повідомляє вам, що ви на 
машині `missing`. Знак `~` (це стандартне позначення home директорії в 
системі) вказує на вашу поточну директорію, тобто місце, де ви зараз 
перебуваєте. Символ `$` вказує на те, що ви не є root користувачем (про 
це пізніше). У цьому вікні ви можете ввести _команду_, яку потім буде 
інтерпретовано командним рядком. Найпростіша команда:

```console
missing:~$ date
Fri 10 Jan 2020 11:49:31 AM EST
missing:~$ 
```

Програма `date` виводить поточну дату і час. Після цього оболонка 
попросить нас виконати іншу команду. Ми також можемо ввести команду з 
_аргументами_:

```console
missing:~$ echo hello
hello
```

У цьому прикладі ми сказали оболонці виконати програму `echo` з аргументом 
`hello`. Програма `echo` просто виводить свої аргументи. Інтерпретатор 
розбирає команду, розділяючи її пробілами. Потім запускає програму, 
вказану першим словом, а кожне наступне слово сприймає як аргумент, до 
якого програма може отримати доступ. Якщо ви хочете вказати аргумент, який 
містить пробіли або інші спеціальні символи (наприклад, директорію з назвою 
"My Photos"), ви можете або взяти аргумент у лапки за допомогою символів `'` 
чи `"` (`"My Photos"`), або використати `\` (`My\ Photos`).

Але звідки оболонка знає, як виконати `date` або `echo` програми? The shell - 
це середовище програмування, так само як Python або Ruby, і тому в ній є 
змінні, умови, цикли й функції (наступна лекція!). Коли ви виконуєте команди 
в оболонці, ви насправді пишете невеликий шматочок коду, який потім 
інтерпретує оболонка. Якщо оболонку просять виконати команду, яка не 
відповідає одному з ключових слів, вона звертається до _змінної оточення_ 
(або _глобальна змінна_), яка позначається `$PATH` і містить список 
директорій (каталогів), серед яких оболонка повинна шукати програми, коли їй 
дають команду:

```console
missing:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
missing:~$ which echo
/bin/echo
missing:~$ /bin/echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

При запуску команди `echo`, оболонка бачить, що вона має виконати програму 
`echo`, а потім шукає у списку директорій у `$PATH`, (директорії відокремлені  
символом `:`), файл з таким іменем. Після знаходження, вона запускає його (за 
умови, що файл є _виконуваним_; про це буде пізніше). Ми можемо дізнатися, 
який файл виконується для даної програми за допомогою `which`. Ми також можемо 
повністю обійти `$PATH`, вказавши _шлях_ до файлу.

## Навігація в оболонці

Шлях в оболонці - це розмежований список директорій, який розділений 
символами `/` на Linux і macOS та `\` на Windows. На Linux і macOS шлях 
`/` є коренем (root) файлової системи, під яким знаходяться всі директорії 
й файли. Тоді як на Windows є один корінь для кожного розділу диска 
(наприклад, `C:\`). На цьому курсі ми будемо вважати, що ви 
використовуєте Linux. Шлях, який починається з `/`, називається 
_абсолютним_ шляхом. Будь-який інший шлях є _відносним_. Відносні шляхи 
пов'язані з поточною робочою директорією, яку ми можемо побачити за 
допомогою команди `pwd` і змінити за допомогою команди `cd`.
`.` вказує на поточну директорію, а `..` - на батьківську директорію:

```console
missing:~$ pwd
/home/missing
missing:~$ cd /home
missing:/home$ pwd
/home
missing:/home$ cd ..
missing:/$ pwd
/
missing:/$ cd ./home
missing:/home$ pwd
/home
missing:/home$ cd missing
missing:~$ pwd
/home/missing
missing:~$ ../../bin/echo hello
hello
```

Зверніть увагу, що командний рядок інформує нас про поточну робочу 
директорію. Ви можете налаштувати командний рядок так, щоб він показував 
вам різну корисну інформацію, про що ми поговоримо в наступній лекції.

Загалом, коли ми запускаємо програму, вона працюватиме в поточній 
директорії, якщо ми не вкажемо їй інше. Наприклад, пошук та створення 
(за необхідності) файлів буде виконуватись у поточній директорії.

Щоб побачити вміст директорії, використовуємо команду `ls`:

```console
missing:~$ ls
missing:~$ cd ..
missing:/home$ ls
missing
missing:/home$ cd ..
missing:/$ ls
bin
boot
dev
etc
home
...
```

Якщо директорію не вказано як перший аргумент, `ls` виведе вміст поточної 
директорії. Більшість команд приймають прапори та опції (прапори зі 
значеннями), які починаються з `-`, щоб змінити їхню поведінку. Якщо 
запустити програму з прапором `-h` або `--help`, буде виведено текст 
довідки, у якому буде вказано, які прапори та опції доступні. Наприклад, 
`ls --help` виведе нам:

```
  -l                         use a long listing format
```

```console
missing:~$ ls -l /home
drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing
```

Це дає нам більше інформації про файл або директорію. По-перше, символ `d` 
на початку рядка вказує на те, що `missing` - це наша директорія. Далі йдуть 
три групи по три символи кожна (`rwx`). Вони вказують на те, які права на 
відповідний об'єкт має власник файлу (`missing`), група власників (`users`), 
та всі інші. `-` вказує на те, що власник не має даного дозволу. Вище 
зазначено, що лише власник має право модифікувати (`w`) `missing` директорію 
(тобто додавати/видаляти файли в ній). Щоб увійти до директорії, користувач 
повинен мати права на "пошук" (позначається як "execute": `x`) у цій 
директорії (та в батьківських). Щоб переглянути вміст директорії, користувач 
повинен мати права на читання (`r`). Зверніть увагу, що майже всі файли в 
директорії `/bin` мають права доступу `x` для останньої групи, "усі інші", 
тому будь-хто може виконувати ці програми.

Деякі інші корисні програми, про які варто знати на цьому етапі: `mv` 
(для перейменування/переміщення файлу), `cp` (для копіювання файлу) і 
`mkdir` (для створення нової директорії).

Для отримання _додаткової_ інформації про аргументи, вхідні та вихідні 
дані програми, або про те, як вона працює загалом, спробуйте використати 
програму `man`. Вона прийме як аргумент назву програми й покаже вам її 
_довідкову сторінку_. Щоб вийти, натисніть `q`.

```console
missing:~$ man ls
```

## Підключення програм

В оболонці програми мають два основні потоки: введення та виведення. 
Коли програма намагається прочитати вхідні дані, вона читає з потоку 
введення, а коли програма виводить дані на екран, то вона працює з потоком 
виведення. Зазвичай, введення та виведення - це ваш термінал. Тобто, 
клавіатура відповідає за введення, а монітор - за виведення. Однак ми 
можемо перепрограмувати ці потоки!

Найпростіший спосіб перенаправлення є команди `< file` і `> file`. Вони 
дозволяють перенаправити потоки введення та виведення програми у файл 
відповідно:

```console
missing:~$ echo hello > hello.txt
missing:~$ cat hello.txt
hello
missing:~$ cat < hello.txt
hello
missing:~$ cat < hello.txt > hello2.txt
missing:~$ cat hello2.txt
hello
```

У наведеному вище прикладі показано, що `cat` - це програма, яка об'єднує 
файли (con`cat`enates files). Коли в ролі аргументів задаються імена файлів, 
програма послідовно виводить вміст кожного з них у вихідний потік. Але коли 
`cat` не отримує жодних аргументів, вона виводить вміст вхідного потоку у 
вихідний потік.

Ви також можете використовувати `>>` для додавання до файлу. Де цей тип 
перенаправлення введення/виведення потрібен, так це у використанні _конвеєрів_. 
Оператор `|` дозволяє вам "з'єднувати" програми таким чином, щоб вивід однієї з 
них був вводом іншої:

```console
missing:~$ ls -l / | tail -n1
drwxr-xr-x 1 root  root  4096 Jun 20  2019 var
missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=' ' -f2
219
```

Більше про використання конвеєрів буде в лекції про обробку даних.

## Універсальний та потужний інструмент

У більшості Unix-подібних систем один користувач є особливим: root 
користувач. Ви могли побачити його в наведених вище списках файлів. 
Користувач root стоїть вище (майже) всіх обмежень доступу й може 
створювати, читати, оновлювати й видаляти будь-які файли в системі. 
Зазвичай ви не будете входити в систему як користувач root, оскільки дуже 
легко щось випадково зламати. Натомість ви будете використовувати команду 
`sudo`. Як випливає з назви, вона дозволяє вам "робити" щось "як su" 
(скорочення від "суперкористувач" або "root"). Коли ви отримуєте відмову 
через відсутність дозволу, це зазвичай пов'язано з тим, що вам потрібно 
щось зробити від імені користувача root. Однак переконайтеся, що ви дійсно 
хочете це зробити!

Права root потрібні для того, щоб мати змогу писати у файлову систему 
`sysfs`, задану як `/sys`. Файлова система `sysfs` надає детальну 
інформацію про параметри ядра, щоб ви могли легко переконфігурувати ядро 
"на льоту" без спеціалізованих інструментів. 
**Зверніть увагу, що `sysfs` не існує в Windows або macOS.**

Наприклад, яскравість екрана вашого ноутбука виставляється за допомогою 
файлу з назвою `brightness` у директорії

```
/sys/class/backlight
```

Після запису значення в цей файл, ми можемо змінювати яскравість екрана. 
Ваша перша думка стосовно того, як це можна зробити, може полягати в 
тому, щоб зробити щось на кшталт:

```console
$ sudo find -L /sys/class/backlight -maxdepth 2 -name '*brightness*'
/sys/class/backlight/thinkpad_screen/brightness
$ cd /sys/class/backlight/thinkpad_screen
$ sudo echo 3 > brightness
An error occurred while redirecting file 'brightness'
open: Permission denied
```

Ця помилка може здивувати. Адже ми виконували команду з `sudo`! Це 
важлива річ, яку потрібно знати про оболонку. Такі операції, як `|`, `>`, 
та `<` виконуються _оболонкою_, а не окремою програмою. `echo` і його 
"друзі" не знають про `|`. Вони просто читають з потоку введення й 
записують у потік виведення, яким би він не був. У наведеному вище випадку
_оболонка_ (яка розпізнається як користувач) намагається відкрити файл 
яскравості для запису, перш ніж встановити його як вивід `sudo echo`. Але 
не може цього зробити, оскільки оболонка не запускається від імені 
користувача root. Використовуючи ці знання, ми можемо обійти цю проблему:

```console
$ echo 3 | sudo tee brightness
```

Оскільки програма `tee` відкриває файл `/sys` для запису, і вона 
запущена від імені користувача root, то всі дозволи працюють. За 
допомогою `/sys` ви можете керувати різними цікавими та корисними речами,
наприклад, станом різних системних світлодіодів (ваш шлях може бути 
іншим):

```console
$ echo 1 | sudo tee /sys/class/leds/input6::scrolllock/brightness
```

# Наступні кроки

На цьому етапі ви знаєте, як працювати в оболонці, і можете виконувати 
базові завдання. Ви повинні вміти знаходити потрібні вам файли, 
переміщатись по них і використовувати основні функції більшості програм. 
У наступній лекції ми поговоримо про те, як виконувати та автоматизувати 
складніші завдання за допомогою оболонки та багатьох зручних програм 
командного рядка.

# Вправи

Усі заняття цього курсу супроводжуються серією вправ. Деякі з них дають вам 
конкретне завдання, інші - відкритого типу (наприклад, "спробуйте використати 
програми X та Y"). Ми наполегливо рекомендуємо вам виконувати їх.

 1. Для проходження цього курсу вам потрібно використовувати Unix-оболонку, таку 
    як Bash або ZSH. Якщо ви користувач Linux або macOS, вам не потрібно додатково
    щось робити. Якщо ж ви користувач Windows, вам потрібно переконатися, що у вас не 
    запущено cmd.exe або PowerShell; ви можете скористатися [Windows Subsystem for
    Linux](https://docs.microsoft.com/en-us/windows/wsl/) або віртуальною машиною 
    Linux, щоб використовувати інструменти командного рядка в стилі Unix. Щоб 
    переконатися, що у вас запущено відповідну оболонку, ви можете спробувати 
    виконати команду `echo $SHELL`. Якщо вона виведе щось на кшталт `/bin/bash` або 
    `/usr/bin/zsh`, це означає, що ви запускаєте потрібну програму.

 2. Створіть нову директорію з іменем `missing` у `/tmp`.
 3. Ознайомтесь з програмою `touch`. Програма `man` допоможе вам у вивченні нових команд.
 4. Використовуючи `touch`, створіть новий файл з іменем `semester` у `missing`.
 5. Запишіть у цей файл наступне, по одному рядку за раз:
    ```
    #!/bin/sh
    curl --head --silent https://missing.csail.mit.edu
    ```
    Перший рядок може бути складним для розуміння. Корисно знати, що `#` 
    означає початок коментаря в Bash. А `!` має особливе значення навіть у 
    рядках з подвійними лапками (`"`). Bash по-іншому поводиться з рядками в 
    одинарних лапках (`'`). Більше інформації можна знайти на сторінці 
    посібника [quoting](https://www.gnu.org/software/bash/manual/html_node/Quoting.html).
 6. Спробуйте запустити скрипт, тобто введіть шлях до нього (`./semester`) 
    в командному рядку й натисніть enter. Спробуйте зрозуміти, чому це не 
    працює за допомогою `ls` (підказка: подивіться на біти дозволу файлу).
 7. Запустіть команду, явно запустивши інтерпретатор `sh` і передавши йому 
    файл `semester` як перший аргумент, тобто `sh semester`. Чому це працює, 
    а `./semester` ні?
 8. Ознайомтесь з `chmod` програмою (за допомогою `man chmod`).
 9. Використовуйте `chmod`, щоб зробити можливим виконання команди `./semester` 
    замість того, щоб вводити `sh semester`. Звідки ваша оболонка знає, що файл 
    слід інтерпретувати за допомогою `sh`? Більше інформації наведено на цій 
    сторінці про рядок [shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)).
 10. Використовуйте `|` та `>`, щоб записати останню змінену дату (the "last 
    modified" date) `semester` у файл з назвою `last-modified.txt` у вашій 
    домашній директорії.
 11. Напишіть команду, яка зчитує рівень заряду батареї вашого ноутбука або 
    температуру процесора настільного комп'ютера з `/sys`. Примітка: якщо ви 
    використовуєте macOS, у вашій ОС немає sysfs, тому ви можете пропустити 
    цю вправу.
